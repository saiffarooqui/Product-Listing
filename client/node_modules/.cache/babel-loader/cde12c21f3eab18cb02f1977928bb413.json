{"ast":null,"code":"/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nforge.cipher = forge.cipher || {}; // supported cipher modes\n\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function (options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function (options) {};\n\nmodes.ecb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // write output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // decrypt block\n\n\n  this.cipher.decrypt(this._inBlock, this._outBlock); // write output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  } // ensure padding byte count is valid\n\n\n  var len = output.length();\n  var count = output.at(len - 1);\n\n  if (count > this.blockSize << 2) {\n    return false;\n  } // trim off padding bytes\n\n\n  output.truncate(count);\n  return true;\n};\n/** Cipher-block Chaining (CBC) **/\n\n\nmodes.cbc = function (options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function (options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if (options.iv === null) {\n    // must have a previous block\n    if (!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n\n    this._iv = this._prev.slice(0);\n  } else if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // write output, save previous block\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  } // get next block\n\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  } // decrypt block\n\n\n  this.cipher.decrypt(this._inBlock, this._outBlock); // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function (input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function (output, options) {\n  // check for error: input data not a multiple of blockSize\n  if (options.overflow > 0) {\n    return false;\n  } // ensure padding byte count is valid\n\n\n  var len = output.length();\n  var count = output.at(len - 1);\n\n  if (count > this.blockSize << 2) {\n    return false;\n  } // trim off padding bytes\n\n\n  output.truncate(count);\n  return true;\n};\n/** Cipher feedback (CFB) **/\n\n\nmodes.cfb = function (options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output, write input as partial output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block (CFB always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output, write input as partial output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n/** Output feedback (OFB) **/\n\n\nmodes.ofb = function (options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (input.length() === 0) {\n    return true;\n  } // encrypt block (OFB always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n\n    return;\n  } // handle partial block\n\n\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n  if (partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  } // XOR input with output\n\n\n  this._partialOutput.clear();\n\n  for (var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if (partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for (var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  } // skip any previous partial bytes\n\n\n  if (this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if (partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n/** Counter (CTR) **/\n\nmodes.ctr = function (options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // use IV as first input\n\n\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block (CTR always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    } // XOR input with output\n\n\n    this._partialOutput.clear();\n\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if (partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    } // skip any previous partial bytes\n\n\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if (partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  } // block complete, increment counter (input block)\n\n\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function (options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0; // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function (options) {\n  if (!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } // ensure IV is a byte buffer\n\n\n  var iv = forge.util.createBuffer(options.iv); // no ciphered data processed yet\n\n  this._cipherLength = 0; // default additional data is none\n\n  var additionalData;\n\n  if ('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  } // default tag length is 128 bits\n\n\n  if ('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  } // if tag is given, ensure tag matches tag length\n\n\n  this._tag = null;\n\n  if (options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n\n    if (this._tag.length !== this._tagLength / 8) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  } // create tmp storage for hash calculation\n\n\n  this._hashBlock = new Array(this._ints); // no tag generated yet\n\n  this.tag = null; // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey); // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits); // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n\n  var ivLength = iv.length();\n\n  if (ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n\n    while (iv.length() > 0) {\n      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n\n    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  } // generate ICB (initial counter block)\n\n\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0; // consume authentication data\n\n  additionalData = forge.util.createBuffer(additionalData); // save additional data length as a BE 64-bit number\n\n  this._aDataLength = from64To32(additionalData.length() * 8); // pad additional data to 128 bit (16 byte) block size\n\n  var overflow = additionalData.length() % this.blockSize;\n\n  if (overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n\n  this._s = [0, 0, 0, 0];\n\n  while (additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function (input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n\n  if (inputLength === 0) {\n    return true;\n  } // encrypt block\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // handle full block\n\n  if (this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for (var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n\n    if (partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    } // XOR input with output\n\n\n    this._partialOutput.clear();\n\n    for (var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if (partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if (finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow; // truncate for hash function\n\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      } // get output block for hashing\n\n\n      for (var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n\n      this._partialOutput.read -= this.blockSize;\n    } // skip any previous partial bytes\n\n\n    if (this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if (partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  } // update hash block S\n\n\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock); // increment counter (input block)\n\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function (input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n\n  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  } // encrypt block (GCM always uses encryption mode)\n\n\n  this.cipher.encrypt(this._inBlock, this._outBlock); // increment counter (input block)\n\n  inc32(this._inBlock); // update hash block S\n\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock); // XOR hash input with output\n\n  for (var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  } // increment cipher data length\n\n\n  if (inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function (output, options) {\n  var rval = true; // handle overflow\n\n  if (options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  } // handle authentication tag\n\n\n  this.tag = forge.util.createBuffer(); // concatenate additional data length with cipher length\n\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8)); // include lengths in hash\n\n\n  this._s = this.ghash(this._hashSubkey, this._s, lengths); // do GCTR(J_0, S)\n\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n\n  for (var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  } // trim tag to length\n\n\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8)); // check authentication tag\n\n  if (options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\n\n\nmodes.gcm.prototype.multiply = function (x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0); // calculate Z_128 (block has 128 bits)\n\n  for (var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;\n\n    if (x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    } // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n\n\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function (x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1; // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n\n  for (var i = 3; i > 0; --i) {\n    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;\n  } // shift the first integer normally\n\n\n  out[0] = x[0] >>> 1; // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n\n  if (lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function (x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n\n  for (var i = 0; i < 32; ++i) {\n    var idx = i / 8 | 0;\n    var x_i = x[idx] >>> (7 - i % 8) * 4 & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n\n  return z;\n};\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\n\n\nmodes.gcm.prototype.ghash = function (h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y); //return this.multiply(y, h);\n};\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\n\n\nmodes.gcm.prototype.generateHashTable = function (h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n\n  for (var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = i / perInt | 0;\n    var shft = (perInt - 1 - i % perInt) * bits;\n    tmp[idx] = 1 << bits - 1 << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n\n  return m;\n};\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\n\n\nmodes.gcm.prototype.generateSubHashTable = function (mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n\n  while (i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n\n  i = 2;\n\n  while (i < half) {\n    for (var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];\n    }\n\n    i *= 2;\n  }\n\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n\n  for (i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n\n  return m;\n};\n/** Utility functions */\n\n\nfunction transformIV(iv, blockSize) {\n  if (typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if (forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n\n    for (var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n\n  if (iv.length() < blockSize) {\n    throw new Error('Invalid IV length; got ' + iv.length() + ' bytes and expected ' + blockSize + ' bytes.');\n  }\n\n  if (!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    var ints = [];\n    var blocks = blockSize / 4;\n\n    for (var i = 0; i < blocks; ++i) {\n      ints.push(iv.getInt32());\n    }\n\n    iv = ints;\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = block[block.length - 1] + 1 & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [num / 0x100000000 | 0, num & 0xFFFFFFFF];\n}","map":{"version":3,"names":["forge","require","cipher","modes","module","exports","ecb","options","name","blockSize","_ints","_inBlock","Array","_outBlock","prototype","start","encrypt","input","output","finish","length","i","getInt32","putInt32","decrypt","pad","padding","fillWithByte","unpad","overflow","len","count","at","truncate","cbc","iv","_prev","Error","_iv","slice","transformIV","cfb","_partialBlock","_partialOutput","util","createBuffer","_partialBytes","inputLength","partialBytes","clear","read","getBytes","putBytes","ofb","ctr","inc32","gcm","_R","_cipherLength","additionalData","_tagLength","tagLength","_tag","tag","_hashBlock","_hashSubkey","componentBits","_m","generateHashTable","ivLength","_j0","ghash","concat","from64To32","_aDataLength","_s","afterFinish","rval","lengths","bytes","multiply","x","y","z_i","v_i","x_i","pow","out","lsb","tableMultiply","z","idx","ah","h","bits","multiplier","perInt","size","m","tmp","shft","generateSubHashTable","mid","half","j","m_i","m_j","c","isArray","putByte","ints","blocks","push","block","num"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/node-forge/lib/cipherModes.js"],"sourcesContent":["/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.cipher = forge.cipher || {};\n\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function(options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function(options) {};\n\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher-block Chaining (CBC) **/\n\nmodes.cbc = function(options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function(options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if(options.iv === null) {\n    // must have a previous block\n    if(!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n    this._iv = this._prev.slice(0);\n  } else if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous block\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher feedback (CFB) **/\n\nmodes.cfb = function(options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\n/** Output feedback (OFB) **/\n\nmodes.ofb = function(options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(input.length() === 0) {\n    return true;\n  }\n\n  // encrypt block (OFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n\n/** Counter (CTR) **/\n\nmodes.ctr = function(options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CTR always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // block complete, increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function(options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n\n  // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // ensure IV is a byte buffer\n  var iv = forge.util.createBuffer(options.iv);\n\n  // no ciphered data processed yet\n  this._cipherLength = 0;\n\n  // default additional data is none\n  var additionalData;\n  if('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  }\n\n  // default tag length is 128 bits\n  if('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  }\n\n  // if tag is given, ensure tag matches tag length\n  this._tag = null;\n  if(options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n    if(this._tag.length !== (this._tagLength / 8)) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  }\n\n  // create tmp storage for hash calculation\n  this._hashBlock = new Array(this._ints);\n\n  // no tag generated yet\n  this.tag = null;\n\n  // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n\n  // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n\n  // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n  var ivLength = iv.length();\n  if(ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n    while(iv.length() > 0) {\n      this._j0 = this.ghash(\n        this._hashSubkey, this._j0,\n        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n    this._j0 = this.ghash(\n      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  }\n\n  // generate ICB (initial counter block)\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0;\n\n  // consume authentication data\n  additionalData = forge.util.createBuffer(additionalData);\n  // save additional data length as a BE 64-bit number\n  this._aDataLength = from64To32(additionalData.length() * 8);\n  // pad additional data to 128 bit (16 byte) block size\n  var overflow = additionalData.length() % this.blockSize;\n  if(overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n  this._s = [0, 0, 0, 0];\n  while(additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32()\n    ]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if(finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow;\n        // truncate for hash function\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n\n      // get output block for hashing\n      for(var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n      this._partialOutput.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // update hash block S\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  }\n\n  // encrypt block (GCM always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n\n  // update hash block S\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n\n  // XOR hash input with output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  }\n\n  // increment cipher data length\n  if(inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function(output, options) {\n  var rval = true;\n\n  // handle overflow\n  if(options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  }\n\n  // handle authentication tag\n  this.tag = forge.util.createBuffer();\n\n  // concatenate additional data length with cipher length\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n\n  // include lengths in hash\n  this._s = this.ghash(this._hashSubkey, this._s, lengths);\n\n  // do GCTR(J_0, S)\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n  for(var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  }\n\n  // trim tag to length\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n\n  // check authentication tag\n  if(options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\nmodes.gcm.prototype.multiply = function(x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0);\n\n  // calculate Z_128 (block has 128 bits)\n  for(var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\n    if(x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    }\n\n    // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function(x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1;\n\n  // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n  for(var i = 3; i > 0; --i) {\n    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\n  }\n  // shift the first integer normally\n  out[0] = x[0] >>> 1;\n\n  // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n  if(lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function(x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n  for(var i = 0; i < 32; ++i) {\n    var idx = (i / 8) | 0;\n    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n  return z;\n};\n\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\nmodes.gcm.prototype.ghash = function(h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y);\n  //return this.multiply(y, h);\n};\n\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateHashTable = function(h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n  for(var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = (i / perInt) | 0;\n    var shft = ((perInt - 1 - (i % perInt)) * bits);\n    tmp[idx] = (1 << (bits - 1)) << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n  return m;\n};\n\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n  while(i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n  i = 2;\n  while(i < half) {\n    for(var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [\n        m_i[0] ^ m_j[0],\n        m_i[1] ^ m_j[1],\n        m_i[2] ^ m_j[2],\n        m_i[3] ^ m_j[3]\n      ];\n    }\n    i *= 2;\n  }\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n  for(i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n  return m;\n};\n\n/** Utility functions */\n\nfunction transformIV(iv, blockSize) {\n  if(typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if(forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n    for(var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n\n  if(iv.length() < blockSize) {\n    throw new Error(\n      'Invalid IV length; got ' + iv.length() +\n      ' bytes and expected ' + blockSize + ' bytes.');\n  }\n\n  if(!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    var ints = [];\n    var blocks = blockSize / 4;\n    for(var i = 0; i < blocks; ++i) {\n      ints.push(iv.getInt32());\n    }\n    iv = ints;\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}