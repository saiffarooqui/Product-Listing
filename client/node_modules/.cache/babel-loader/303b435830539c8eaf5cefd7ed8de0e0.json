{"ast":null,"code":"\"use strict\"; // Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluggableAuthHandler = void 0;\n\nconst pluggable_auth_client_1 = require(\"./pluggable-auth-client\");\n\nconst executable_response_1 = require(\"./executable-response\");\n\nconst childProcess = require(\"child_process\");\n\nconst fs = require(\"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\n\n\nclass PluggableAuthHandler {\n  /**\n   * Instantiates a PluggableAuthHandler instance using the provided\n   * PluggableAuthHandlerOptions object.\n   */\n  constructor(options) {\n    if (!options.command) {\n      throw new Error('No command provided.');\n    }\n\n    this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n    this.timeoutMillis = options.timeoutMillis;\n\n    if (!this.timeoutMillis) {\n      throw new Error('No timeoutMillis provided.');\n    }\n\n    this.outputFile = options.outputFile;\n  }\n  /**\n   * Calls user provided executable to get a 3rd party subject token and\n   * returns the response.\n   * @param envMap a Map of additional Environment Variables required for\n   *   the executable.\n   * @return A promise that resolves with the executable response.\n   */\n\n\n  retrieveResponseFromExecutable(envMap) {\n    return new Promise((resolve, reject) => {\n      // Spawn process to run executable using added environment variables.\n      const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n        env: { ...process.env,\n          ...Object.fromEntries(envMap)\n        }\n      });\n      let output = ''; // Append stdout to output as executable runs.\n\n      child.stdout.on('data', data => {\n        output += data;\n      }); // Append stderr as executable runs.\n\n      child.stderr.on('data', err => {\n        output += err;\n      }); // Set up a timeout to end the child process and throw an error.\n\n      const timeout = setTimeout(() => {\n        // Kill child process and remove listeners so 'close' event doesn't get\n        // read after child process is killed.\n        child.removeAllListeners();\n        child.kill();\n        return reject(new Error('The executable failed to finish within the timeout specified.'));\n      }, this.timeoutMillis);\n      child.on('close', code => {\n        // Cancel timeout if executable closes before timeout is reached.\n        clearTimeout(timeout);\n\n        if (code === 0) {\n          // If the executable completed successfully, try to return the parsed response.\n          try {\n            const responseJson = JSON.parse(output);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            return resolve(response);\n          } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n              return reject(error);\n            }\n\n            return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n          }\n        } else {\n          return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n        }\n      });\n    });\n  }\n  /**\n   * Checks user provided output file for response from previous run of\n   * executable and return the response if it exists, is formatted correctly, and is not expired.\n   */\n\n\n  async retrieveCachedResponse() {\n    if (!this.outputFile || this.outputFile.length === 0) {\n      return undefined;\n    }\n\n    let filePath;\n\n    try {\n      filePath = await fs.promises.realpath(this.outputFile);\n    } catch (_a) {\n      // If file path cannot be resolved, return undefined.\n      return undefined;\n    }\n\n    if (!(await fs.promises.lstat(filePath)).isFile()) {\n      // If path does not lead to file, return undefined.\n      return undefined;\n    }\n\n    const responseString = await fs.promises.readFile(filePath, {\n      encoding: 'utf8'\n    });\n\n    if (responseString === '') {\n      return undefined;\n    }\n\n    try {\n      const responseJson = JSON.parse(responseString);\n      const response = new executable_response_1.ExecutableResponse(responseJson); // Check if response is successful and unexpired.\n\n      if (response.isValid()) {\n        return new executable_response_1.ExecutableResponse(responseJson);\n      }\n\n      return undefined;\n    } catch (error) {\n      if (error instanceof executable_response_1.ExecutableResponseError) {\n        throw error;\n      }\n\n      throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n    }\n  }\n  /**\n   * Parses given command string into component array, splitting on spaces unless\n   * spaces are between quotation marks.\n   */\n\n\n  static parseCommand(command) {\n    // Split the command into components by splitting on spaces,\n    // unless spaces are contained in quotation marks.\n    const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n\n    if (!components) {\n      throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n    } // Remove quotation marks from the beginning and end of each component if they are present.\n\n\n    for (let i = 0; i < components.length; i++) {\n      if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n        components[i] = components[i].slice(1, -1);\n      }\n    }\n\n    return components;\n  }\n\n}\n\nexports.PluggableAuthHandler = PluggableAuthHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","PluggableAuthHandler","pluggable_auth_client_1","require","executable_response_1","childProcess","fs","constructor","options","command","Error","commandComponents","parseCommand","timeoutMillis","outputFile","retrieveResponseFromExecutable","envMap","Promise","resolve","reject","child","spawn","slice","env","process","fromEntries","output","stdout","on","data","stderr","err","timeout","setTimeout","removeAllListeners","kill","code","clearTimeout","responseJson","JSON","parse","response","ExecutableResponse","error","ExecutableResponseError","ExecutableError","toString","retrieveCachedResponse","length","undefined","filePath","promises","realpath","_a","lstat","isFile","responseString","readFile","encoding","isValid","components","match","i"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = require(\"./pluggable-auth-client\");\nconst executable_response_1 = require(\"./executable-response\");\nconst childProcess = require(\"child_process\");\nconst fs = require(\"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */\n    constructor(options) {\n        if (!options.command) {\n            throw new Error('No command provided.');\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error('No timeoutMillis provided.');\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */\n    retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject) => {\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: { ...process.env, ...Object.fromEntries(envMap) },\n            });\n            let output = '';\n            // Append stdout to output as executable runs.\n            child.stdout.on('data', (data) => {\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on('data', (err) => {\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(() => {\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error('The executable failed to finish within the timeout specified.'));\n            }, this.timeoutMillis);\n            child.on('close', (code) => {\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    }\n                    catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                }\n                else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n    async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        }\n        catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: 'utf8',\n        });\n        if (responseString === '') {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        }\n        catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n    static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for (let i = 0; i < components.length; i++) {\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceMappingURL=pluggable-auth-handler.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}