{"ast":null,"code":"/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nvar _crypto = null;\n\nif (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n/* PRNG API */\n\n\nvar prng = module.exports = forge.prng = forge.prng || {};\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\n\nprng.create = function (plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  }; // create 32 entropy pools (each is a message digest)\n\n  var md = plugin.md;\n  var pools = new Array(32);\n\n  for (var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n\n  ctx.pools = pools; // entropy pools are written to cyclically, starting at index 0\n\n  ctx.pool = 0;\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n\n  ctx.generate = function (count, callback) {\n    // do synchronously\n    if (!callback) {\n      return ctx.generateSync(count);\n    } // simple generator using counter-based CBC\n\n\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer(); // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n\n    ctx.key = null;\n    generate();\n\n    function generate(err) {\n      if (err) {\n        return callback(err);\n      } // sufficient bytes generated\n\n\n      if (b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      } // if amount of data generated is greater than 1 MiB, trigger reseed\n\n\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if (ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function () {\n          _reseed(generate);\n        });\n      } // generate the random bytes\n\n\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes); // generate bytes for a new key and seed\n\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n      forge.util.setImmediate(generate);\n    }\n  };\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n\n\n  ctx.generateSync = function (count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed; // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n\n    ctx.key = null;\n    var b = forge.util.createBuffer();\n\n    while (b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if (ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if (ctx.key === null) {\n        _reseedSync();\n      } // generate the random bytes\n\n\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes); // generate bytes for a new key and seed\n\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n\n\n  function _reseed(callback) {\n    if (ctx.pools[0].messageLength >= 32) {\n      _seed();\n\n      return callback();\n    } // not enough seed data...\n\n\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.seedFile(needed, function (err, bytes) {\n      if (err) {\n        return callback(err);\n      }\n\n      ctx.collect(bytes);\n\n      _seed();\n\n      callback();\n    });\n  }\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n\n\n  function _reseedSync() {\n    if (ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    } // not enough seed data...\n\n\n    var needed = 32 - ctx.pools[0].messageLength << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n\n    _seed();\n  }\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n\n\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = ctx.reseeds === 0xffffffff ? 0 : ctx.reseeds + 1; // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n    // create a plugin-based message digest\n\n    var md = ctx.plugin.md.create(); // consume current key bytes\n\n    md.update(ctx.keyBytes); // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n\n    var _2powK = 1;\n\n    for (var k = 0; k < 32; ++k) {\n      if (ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n\n      _2powK = _2powK << 1;\n    } // get digest for key bytes\n\n\n    ctx.keyBytes = md.digest().getBytes(); // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes(); // update state\n\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n\n\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n\n    if (_crypto && _crypto.getRandomValues) {\n      getRandomValues = function (arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n\n    if (getRandomValues) {\n      while (b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n\n        try {\n          getRandomValues(entropy);\n\n          for (var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch (e) {\n          /* only ignore QuotaExceededError */\n          if (!(typeof QuotaExceededError !== 'undefined' && e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    } // be sad and add some weak random data\n\n\n    if (b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n\n      while (b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF; // consume lower 3 bytes of seed\n\n        for (var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(next & 0xFF);\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  } // initialize seed file APIs\n\n\n  if (_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function (needed, callback) {\n      _crypto.randomBytes(needed, function (err, bytes) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, bytes.toString());\n      });\n    }; // use nodejs sync API\n\n\n    ctx.seedFileSync = function (needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function (needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    ctx.seedFileSync = defaultSeedFile;\n  }\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n\n\n  ctx.collect = function (bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n\n    for (var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;\n    }\n  };\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n\n\n  ctx.collectInt = function (i, n) {\n    var bytes = '';\n\n    for (var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode(i >> x & 0xFF);\n    }\n\n    ctx.collect(bytes);\n  };\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n\n\n  ctx.registerWorker = function (worker) {\n    // worker receives random bytes\n    if (worker === self) {\n      ctx.seedFile = function (needed, callback) {\n        function listener(e) {\n          var data = e.data;\n\n          if (data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n\n        self.addEventListener('message', listener);\n        self.postMessage({\n          forge: {\n            prng: {\n              needed: needed\n            }\n          }\n        });\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function (e) {\n        var data = e.data;\n\n        if (data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function (err, bytes) {\n            worker.postMessage({\n              forge: {\n                prng: {\n                  err: err,\n                  bytes: bytes\n                }\n              }\n            });\n          });\n        }\n      }; // TODO: do we need to remove the event listener when the worker dies?\n\n\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};","map":{"version":3,"names":["forge","require","_crypto","util","isNodejs","options","usePureJavaScript","process","versions","prng","module","exports","create","plugin","ctx","key","seed","time","reseeds","generated","keyBytes","md","pools","Array","i","pool","generate","count","callback","generateSync","cipher","increment","formatKey","formatSeed","b","createBuffer","err","length","getBytes","nextTick","_reseed","bytes","putBytes","setImmediate","_reseedSync","messageLength","_seed","needed","seedFile","collect","seedFileSync","update","_2powK","k","digest","start","seedBytes","defaultSeedFile","getRandomValues","globalScope","crypto","msCrypto","arr","Math","max","min","entropy","Uint32Array","floor","putInt32","e","QuotaExceededError","hi","lo","next","random","putByte","randomBytes","toString","substr","collectInt","n","x","String","fromCharCode","registerWorker","worker","self","listener","data","removeEventListener","addEventListener","postMessage"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/node-forge/lib/prng.js"],"sourcesContent":["/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nvar _crypto = null;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n  !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function(plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for(var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function(count, callback) {\n    // do synchronously\n    if(!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n\n    generate();\n\n    function generate(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if(b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function() {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function(count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n\n    var b = forge.util.createBuffer();\n    while(b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if(ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.seedFile(needed, function(err, bytes) {\n      if(err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if(ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for(var k = 0; k < 32; ++k) {\n      if(ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if(_crypto && _crypto.getRandomValues) {\n      getRandomValues = function(arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n    if(getRandomValues) {\n      while(b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for(var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch(e) {\n          /* only ignore QuotaExceededError */\n          if(!(typeof QuotaExceededError !== 'undefined' &&\n            e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if(b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while(b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for(var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(next & 0xFF);\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if(_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function(needed, callback) {\n      _crypto.randomBytes(needed, function(err, bytes) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function(needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function(needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch(e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function(bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for(var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function(i, n) {\n    var bytes = '';\n    for(var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode((i >> x) & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function(worker) {\n    // worker receives random bytes\n    if(worker === self) {\n      ctx.seedFile = function(needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if(data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({forge: {prng: {needed: needed}}});\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function(e) {\n        var data = e.data;\n        if(data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}