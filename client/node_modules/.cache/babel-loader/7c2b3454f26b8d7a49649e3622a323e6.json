{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n    CLASS_UNIVERSAL = 0,\n    PRIMITIVE_BIT = 0x20,\n    TAG_SEQ = 0x10,\n    TAG_INT = 0x02,\n    ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6,\n    ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\n\nfunction base64Url(base64) {\n  return base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n  if (Buffer.isBuffer(signature)) {\n    return signature;\n  } else if ('string' === typeof signature) {\n    return Buffer.from(signature, 'base64');\n  }\n\n  throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg); // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n\n  var maxEncodedParamLength = paramBytes + 1;\n  var inputLength = signature.length;\n  var offset = 0;\n\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n\n  var seqLength = signature[offset++];\n\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n\n  var rLength = signature[offset++];\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n  }\n\n  var rOffset = offset;\n  offset += rLength;\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n\n  var sLength = signature[offset++];\n\n  if (inputLength - offset !== sLength) {\n    throw new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n  }\n\n  var sOffset = offset;\n  offset += sLength;\n\n  if (offset !== inputLength) {\n    throw new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n  }\n\n  var rPadding = paramBytes - rLength,\n      sPadding = paramBytes - sLength;\n  var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  dst = dst.toString('base64');\n  dst = base64Url(dst);\n  return dst;\n}\n\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n\n  var needsSign = buf[start + padding] >= MAX_OCTET;\n\n  if (needsSign) {\n    --padding;\n  }\n\n  return padding;\n}\n\nfunction joseToDer(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  var signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n  }\n\n  var rPadding = countPadding(signature, 0, paramBytes);\n  var sPadding = countPadding(signature, paramBytes, signature.length);\n  var rLength = paramBytes - rPadding;\n  var sLength = paramBytes - sPadding;\n  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  var shortLength = rsBytes < MAX_OCTET;\n  var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // length, base 256\n\n    dst[offset++] = rsBytes & 0xff;\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n\n  return dst;\n}\n\nmodule.exports = {\n  derToJose: derToJose,\n  joseToDer: joseToDer\n};","map":{"version":3,"names":["Buffer","require","getParamBytesForAlg","MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","base64Url","base64","replace","signatureAsBuffer","signature","isBuffer","from","TypeError","derToJose","alg","paramBytes","maxEncodedParamLength","inputLength","length","offset","Error","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","toString","countPadding","buf","start","stop","padding","needsSign","joseToDer","signatureBytes","rsBytes","shortLength","module","exports"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"],"sourcesContent":["'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n\tCLASS_UNIVERSAL = 0,\n\tPRIMITIVE_BIT = 0x20,\n\tTAG_SEQ = 0x10,\n\tTAG_INT = 0x02,\n\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\n\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\n\nfunction base64Url(base64) {\n\treturn base64\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n\tif (Buffer.isBuffer(signature)) {\n\t\treturn signature;\n\t} else if ('string' === typeof signature) {\n\t\treturn Buffer.from(signature, 'base64');\n\t}\n\n\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\t// the DER encoded param should at most be the param size, plus a padding\n\t// zero, since due to being a signed integer\n\tvar maxEncodedParamLength = paramBytes + 1;\n\n\tvar inputLength = signature.length;\n\n\tvar offset = 0;\n\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\n\t\tthrow new Error('Could not find expected \"seq\"');\n\t}\n\n\tvar seqLength = signature[offset++];\n\tif (seqLength === (MAX_OCTET | 1)) {\n\t\tseqLength = signature[offset++];\n\t}\n\n\tif (inputLength - offset < seqLength) {\n\t\tthrow new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n\t}\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"r\"');\n\t}\n\n\tvar rLength = signature[offset++];\n\n\tif (inputLength - offset - 2 < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n\t}\n\n\tif (maxEncodedParamLength < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar rOffset = offset;\n\toffset += rLength;\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"s\"');\n\t}\n\n\tvar sLength = signature[offset++];\n\n\tif (inputLength - offset !== sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n\t}\n\n\tif (maxEncodedParamLength < sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar sOffset = offset;\n\toffset += sLength;\n\n\tif (offset !== inputLength) {\n\t\tthrow new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n\t}\n\n\tvar rPadding = paramBytes - rLength,\n\t\tsPadding = paramBytes - sLength;\n\n\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n\tfor (offset = 0; offset < rPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n\n\toffset = paramBytes;\n\n\tfor (var o = offset; offset < o + sPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n\n\tdst = dst.toString('base64');\n\tdst = base64Url(dst);\n\n\treturn dst;\n}\n\nfunction countPadding(buf, start, stop) {\n\tvar padding = 0;\n\twhile (start + padding < stop && buf[start + padding] === 0) {\n\t\t++padding;\n\t}\n\n\tvar needsSign = buf[start + padding] >= MAX_OCTET;\n\tif (needsSign) {\n\t\t--padding;\n\t}\n\n\treturn padding;\n}\n\nfunction joseToDer(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\tvar signatureBytes = signature.length;\n\tif (signatureBytes !== paramBytes * 2) {\n\t\tthrow new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n\t}\n\n\tvar rPadding = countPadding(signature, 0, paramBytes);\n\tvar sPadding = countPadding(signature, paramBytes, signature.length);\n\tvar rLength = paramBytes - rPadding;\n\tvar sLength = paramBytes - sPadding;\n\n\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n\n\tvar shortLength = rsBytes < MAX_OCTET;\n\n\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n\n\tvar offset = 0;\n\tdst[offset++] = ENCODED_TAG_SEQ;\n\tif (shortLength) {\n\t\t// Bit 8 has value \"0\"\n\t\t// bits 7-1 give the length.\n\t\tdst[offset++] = rsBytes;\n\t} else {\n\t\t// Bit 8 of first octet has value \"1\"\n\t\t// bits 7-1 give the number of additional length octets.\n\t\tdst[offset++] = MAX_OCTET\t| 1;\n\t\t// length, base 256\n\t\tdst[offset++] = rsBytes & 0xff;\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = rLength;\n\tif (rPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\toffset += signature.copy(dst, offset, 0, paramBytes);\n\t} else {\n\t\toffset += signature.copy(dst, offset, rPadding, paramBytes);\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = sLength;\n\tif (sPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\tsignature.copy(dst, offset, paramBytes);\n\t} else {\n\t\tsignature.copy(dst, offset, paramBytes + sPadding);\n\t}\n\n\treturn dst;\n}\n\nmodule.exports = {\n\tderToJose: derToJose,\n\tjoseToDer: joseToDer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}