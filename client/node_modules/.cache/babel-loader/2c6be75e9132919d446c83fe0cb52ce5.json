{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = __importDefault(require(\"net\"));\n\nconst tls_1 = __importDefault(require(\"tls\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst agent_base_1 = require(\"agent-base\");\n\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\n\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\n\nclass HttpsProxyAgent extends agent_base_1.Agent {\n  constructor(_opts) {\n    let opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('creating new HttpsProxyAgent instance: %o', opts);\n    super(opts);\n    const proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = this.secureProxy ? 443 : 80;\n    } // ALPN is supported by Node.js >= v5.\n    // attempt to negotiate http/1.1 for proxy servers that support http/2\n\n\n    if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n      proxy.ALPNProtocols = ['http 1.1'];\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    this.proxy = proxy;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  callback(req, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        proxy,\n        secureProxy\n      } = this; // Create a socket connection to the proxy server.\n\n      let socket;\n\n      if (secureProxy) {\n        debug('Creating `tls.Socket`: %o', proxy);\n        socket = tls_1.default.connect(proxy);\n      } else {\n        debug('Creating `net.Socket`: %o', proxy);\n        socket = net_1.default.connect(proxy);\n      }\n\n      const headers = Object.assign({}, proxy.headers);\n      const hostname = `${opts.host}:${opts.port}`;\n      let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`; // Inject the `Proxy-Authorization` header if necessary.\n\n      if (proxy.auth) {\n        headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n      } // The `Host` header should only include the port\n      // number when it is not the default port.\n\n\n      let {\n        host,\n        port,\n        secureEndpoint\n      } = opts;\n\n      if (!isDefaultPort(port, secureEndpoint)) {\n        host += `:${port}`;\n      }\n\n      headers.Host = host;\n      headers.Connection = 'close';\n\n      for (const name of Object.keys(headers)) {\n        payload += `${name}: ${headers[name]}\\r\\n`;\n      }\n\n      const proxyResponsePromise = parse_proxy_response_1.default(socket);\n      socket.write(`${payload}\\r\\n`);\n      const {\n        statusCode,\n        buffered\n      } = yield proxyResponsePromise;\n\n      if (statusCode === 200) {\n        req.once('socket', resume);\n\n        if (opts.secureEndpoint) {\n          // The proxy is connecting to a TLS server, so upgrade\n          // this socket connection to a TLS connection.\n          debug('Upgrading socket connection to TLS');\n          const servername = opts.servername || opts.host;\n          return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {\n            socket,\n            servername\n          }));\n        }\n\n        return socket;\n      } // Some other status code that's not 200... need to re-play the HTTP\n      // header \"data\" events onto the socket once the HTTP machinery is\n      // attached so that the node core `http` can parse and handle the\n      // error status code.\n      // Close the original socket, and a new \"fake\" socket is returned\n      // instead, so that the proxy doesn't get the HTTP request\n      // written to it (which may contain `Authorization` headers or other\n      // sensitive data).\n      //\n      // See: https://hackerone.com/reports/541502\n\n\n      socket.destroy();\n      const fakeSocket = new net_1.default.Socket({\n        writable: false\n      });\n      fakeSocket.readable = true; // Need to wait for the \"socket\" event to re-play the \"data\" events.\n\n      req.once('socket', s => {\n        debug('replaying proxy buffer for failed request');\n        assert_1.default(s.listenerCount('data') > 0); // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n        // this point the HTTP module machinery has been hooked up for\n        // the user.\n\n        s.push(buffered);\n        s.push(null);\n      });\n      return fakeSocket;\n    });\n  }\n\n}\n\nexports.default = HttpsProxyAgent;\n\nfunction resume(socket) {\n  socket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n\nfunction omit(obj) {\n  const ret = {};\n  let key;\n\n  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","HttpsProxyAgent","agent_base_1","constructor","_opts","opts","url_1","parse","Error","proxy","secureProxy","isHTTPS","protocol","host","hostname","port","parseInt","ALPNProtocols","path","pathname","callback","req","socket","tls_1","connect","net_1","headers","payload","auth","Buffer","from","toString","secureEndpoint","isDefaultPort","Host","Connection","name","Object","keys","proxyResponsePromise","parse_proxy_response_1","write","statusCode","buffered","once","resume","servername","omit","destroy","fakeSocket","Socket","writable","readable","s","assert_1","listenerCount","push","exports","secure","Boolean","test","obj","ret","key","includes"],"sources":["../src/agent.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}