{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Endpoint = void 0;\n\nconst apirequest_1 = require(\"./apirequest\");\n\nclass Endpoint {\n  constructor(options) {\n    this._options = options || {};\n  }\n  /**\n   * Given a schema, add methods and resources to a target.\n   *\n   * @param {object} target The target to which to apply the schema.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods and\n   * resources.\n   * @param {object} context The context to add to each method.\n   */\n\n\n  applySchema(target, rootSchema, schema, context) {\n    this.applyMethodsFromSchema(target, rootSchema, schema, context);\n\n    if (schema.resources) {\n      for (const resourceName in schema.resources) {\n        if (Object.prototype.hasOwnProperty.call(schema.resources, resourceName)) {\n          const resource = schema.resources[resourceName];\n\n          if (!target[resourceName]) {\n            target[resourceName] = {};\n          }\n\n          this.applySchema(target[resourceName], rootSchema, resource, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a schema, add methods to a target.\n   *\n   * @param {object} target The target to which to apply the methods.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods.\n   * @param {object} context The context to add to each method.\n   */\n\n\n  applyMethodsFromSchema(target, rootSchema, schema, context) {\n    if (schema.methods) {\n      for (const name in schema.methods) {\n        if (Object.prototype.hasOwnProperty.call(schema.methods, name)) {\n          const method = schema.methods[name];\n          target[name] = this.makeMethod(rootSchema, method, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a method schema, add a method to a target.\n   *\n   * @param target The target to which to add the method.\n   * @param schema The top-level schema that contains the rootUrl, etc.\n   * @param method The method schema from which to generate the method.\n   * @param context The context to add to the method.\n   */\n\n\n  makeMethod(schema, method, context) {\n    return (paramsOrCallback, callback) => {\n      const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n      callback = typeof paramsOrCallback === 'function' ? paramsOrCallback : callback;\n      const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n      const parameters = {\n        options: {\n          url: schemaUrl.substring(1, schemaUrl.length - 1),\n          method: method.httpMethod\n        },\n        params,\n        requiredParams: method.parameterOrder || [],\n        pathParams: this.getPathParams(method.parameters),\n        context\n      };\n\n      if (method.mediaUpload && method.mediaUpload.protocols && method.mediaUpload.protocols.simple && method.mediaUpload.protocols.simple.path) {\n        const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n        parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n      }\n\n      if (!callback) {\n        return (0, apirequest_1.createAPIRequest)(parameters);\n      }\n\n      (0, apirequest_1.createAPIRequest)(parameters, callback);\n      return;\n    };\n  }\n\n  getPathParams(params) {\n    const pathParams = new Array();\n\n    if (typeof params !== 'object') {\n      params = {};\n    }\n\n    Object.keys(params).forEach(key => {\n      if (params[key].location === 'path') {\n        pathParams.push(key);\n      }\n    });\n    return pathParams;\n  }\n\n}\n\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\n\nfunction buildurl(input) {\n  return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Endpoint","apirequest_1","require","constructor","options","_options","applySchema","target","rootSchema","schema","context","applyMethodsFromSchema","resources","resourceName","prototype","hasOwnProperty","call","resource","methods","name","method","makeMethod","paramsOrCallback","callback","params","schemaUrl","buildurl","rootUrl","servicePath","path","parameters","url","substring","length","httpMethod","requiredParams","parameterOrder","pathParams","getPathParams","mediaUpload","protocols","simple","mediaUrl","createAPIRequest","Array","keys","forEach","key","location","push","input","replace"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/googleapis-common/build/src/endpoint.js"],"sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Endpoint = void 0;\nconst apirequest_1 = require(\"./apirequest\");\nclass Endpoint {\n    constructor(options) {\n        this._options = options || {};\n    }\n    /**\n     * Given a schema, add methods and resources to a target.\n     *\n     * @param {object} target The target to which to apply the schema.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods and\n     * resources.\n     * @param {object} context The context to add to each method.\n     */\n    applySchema(target, rootSchema, schema, context) {\n        this.applyMethodsFromSchema(target, rootSchema, schema, context);\n        if (schema.resources) {\n            for (const resourceName in schema.resources) {\n                if (Object.prototype.hasOwnProperty.call(schema.resources, resourceName)) {\n                    const resource = schema.resources[resourceName];\n                    if (!target[resourceName]) {\n                        target[resourceName] = {};\n                    }\n                    this.applySchema(target[resourceName], rootSchema, resource, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a schema, add methods to a target.\n     *\n     * @param {object} target The target to which to apply the methods.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods.\n     * @param {object} context The context to add to each method.\n     */\n    applyMethodsFromSchema(target, rootSchema, schema, context) {\n        if (schema.methods) {\n            for (const name in schema.methods) {\n                if (Object.prototype.hasOwnProperty.call(schema.methods, name)) {\n                    const method = schema.methods[name];\n                    target[name] = this.makeMethod(rootSchema, method, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a method schema, add a method to a target.\n     *\n     * @param target The target to which to add the method.\n     * @param schema The top-level schema that contains the rootUrl, etc.\n     * @param method The method schema from which to generate the method.\n     * @param context The context to add to the method.\n     */\n    makeMethod(schema, method, context) {\n        return (paramsOrCallback, callback) => {\n            const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n            callback =\n                typeof paramsOrCallback === 'function'\n                    ? paramsOrCallback\n                    : callback;\n            const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n            const parameters = {\n                options: {\n                    url: schemaUrl.substring(1, schemaUrl.length - 1),\n                    method: method.httpMethod,\n                },\n                params,\n                requiredParams: method.parameterOrder || [],\n                pathParams: this.getPathParams(method.parameters),\n                context,\n            };\n            if (method.mediaUpload &&\n                method.mediaUpload.protocols &&\n                method.mediaUpload.protocols.simple &&\n                method.mediaUpload.protocols.simple.path) {\n                const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n                parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n            }\n            if (!callback) {\n                return (0, apirequest_1.createAPIRequest)(parameters);\n            }\n            (0, apirequest_1.createAPIRequest)(parameters, callback);\n            return;\n        };\n    }\n    getPathParams(params) {\n        const pathParams = new Array();\n        if (typeof params !== 'object') {\n            params = {};\n        }\n        Object.keys(params).forEach(key => {\n            if (params[key].location === 'path') {\n                pathParams.push(key);\n            }\n        });\n        return pathParams;\n    }\n}\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\nfunction buildurl(input) {\n    return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}\n//# sourceMappingURL=endpoint.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}