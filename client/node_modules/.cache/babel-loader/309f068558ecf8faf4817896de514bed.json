{"ast":null,"code":"/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */\nvar forge = require('./forge');\n\nrequire('./asn1');\n\nrequire('./hmac');\n\nrequire('./oids');\n\nrequire('./pkcs7asn1');\n\nrequire('./pbe');\n\nrequire('./random');\n\nrequire('./rsa');\n\nrequire('./sha1');\n\nrequire('./util');\n\nrequire('./x509'); // shortcut for asn.1 & PKI API\n\n\nvar asn1 = forge.asn1;\nvar pki = forge.pki; // shortcut for PKCS#12 API\n\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n\n    /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */\n\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for (var i = 0; i < safeContents.length; i++) {\n    for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n\n      if (bagType !== undefined && bag.type !== bagType) {\n        continue;\n      } // only filter by bag type, no attribute specified\n\n\n      if (attrName === null) {\n        result.push(bag);\n        continue;\n      }\n\n      if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */\n\n\np12.pkcs12FromAsn1 = function (obj, strict, password) {\n  // handle args\n  if (typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if (strict === undefined) {\n    strict = true;\n  } // validate PFX and capture data\n\n\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */\n    getBags: function (filter) {\n      var rval = {};\n      var localKeyId;\n\n      if ('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if ('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      } // filter on bagType only\n\n\n      if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if (localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);\n      }\n\n      if ('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */\n    getBagsByFriendlyName: function (friendlyName, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */\n    getBagsByLocalKeyId: function (localKeyId, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if (capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n\n  if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n\n  data = _decodePkcs7Data(data); // check for MAC\n\n  if (capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n\n    switch (macAlgorithm) {\n      case pki.oids.sha1:\n        md = forge.md.sha1.create();\n        macKeyBytes = 20;\n        break;\n\n      case pki.oids.sha256:\n        md = forge.md.sha256.create();\n        macKeyBytes = 32;\n        break;\n\n      case pki.oids.sha384:\n        md = forge.md.sha384.create();\n        macKeyBytes = 48;\n        break;\n\n      case pki.oids.sha512:\n        md = forge.md.sha512.create();\n        macKeyBytes = 64;\n        break;\n\n      case pki.oids.md5:\n        md = forge.md.md5.create();\n        macKeyBytes = 16;\n        break;\n    }\n\n    if (md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    } // verify MAC (iterations default to 1)\n\n\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = 'macIterations' in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n    var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n\n    if (macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n\n  return pfx;\n};\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */\n\n\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if (data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n\n    for (var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n\n  return data;\n}\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */\n\n\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);\n  /* actually it's BER encoded */\n\n  if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');\n  }\n\n  for (var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i]; // validate contentInfo and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n\n    switch (asn1.derToOid(capture.contentType)) {\n      case pki.oids.data:\n        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n          throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n        }\n\n        safeContents = _decodePkcs7Data(data).value;\n        break;\n\n      case pki.oids.encryptedData:\n        safeContents = _decryptSafeContents(data, password);\n        obj.encrypted = true;\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 contentType.');\n        error.contentType = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */\n\n\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n\n  if (oid !== pki.oids.data) {\n    var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  } // get cipher\n\n\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password); // get encrypted data\n\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n  cipher.update(encrypted);\n\n  if (!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */\n\n\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if (!strict && safeContents.length === 0) {\n    return [];\n  } // actually it's BER-encoded\n\n\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n    throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n\n  for (var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i]; // validate SafeBag and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n    /* Create bag object and push to result array. */\n\n\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n\n    switch (bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n\n        if (bagAsn1 === null) {\n          throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n      /* fall through */\n\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch (e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n\n        continue;\n\n      /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n\n        decoder = function () {\n          if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error('Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          } // true=produce cert hash\n\n\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch (e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n\n\n    if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n    /* Call decoder function from above to store the results. */\n\n\n    decoder();\n  }\n\n  return res;\n}\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */\n\n\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if (attributes !== undefined) {\n    for (var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n\n      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n\n      if (pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n\n      for (var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */\n\n\np12.toPkcs12Asn1 = function (key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n\n  if (!('useMac' in options)) {\n    options.useMac = true;\n  }\n\n  if (!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n\n  if (!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n\n  if (localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if (options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if (cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n\n      if (typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n\n  if (localKeyId !== null) {\n    attrs.push( // localKeyID\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));\n  }\n\n  if ('friendlyName' in options) {\n    attrs.push( // friendlyName\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));\n  }\n\n  if (attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  } // collect contents for AuthenticatedSafe\n\n\n  var contents = []; // create safe bag(s) for certificate chain\n\n  var chain = [];\n\n  if (cert !== null) {\n    if (forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n\n  for (var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n\n    if (typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    } // SafeBag\n\n\n    var certBagAttrs = i === 0 ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), // bagValue\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// CertBag\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// certId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), // certValue (x509Certificate)\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), // bagAttributes (OPTIONAL)\n    certBagAttrs]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if (certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags); // ContentInfo\n\n    var certCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);\n    contents.push(certCI);\n  } // create safe contents for private key\n\n\n  var keyBag = null;\n\n  if (key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n\n    if (password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// PrivateKeyInfo\n      pkAsn1]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// EncryptedPrivateKeyInfo\n      pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } // SafeContents\n\n\n    var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]); // ContentInfo\n\n    var keyCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);\n    contents.push(keyCI);\n  } // create AuthenticatedSafe by stringing together the contents\n\n\n  var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n  var macData;\n\n  if (options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n    var count = options.count; // 160-bit key\n\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// mac DigestInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm = SHA-1\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), // parameters = Null\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // digest\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), // macSalt OCTET STRING\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), // iterations INTEGER (XXX: Only support count < 65536)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);\n  } // PFX\n\n\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version (3)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), // PKCS#7 ContentInfo\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n  asn1.oidToDer(pki.oids.data).getBytes()), // content\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);\n};\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\n\n\np12.generateKey = forge.pbe.generatePkcs12Key;","map":{"version":3,"names":["forge","require","asn1","pki","p12","module","exports","pkcs12","contentInfoValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","OID","capture","CONTEXT_SPECIFIC","captureAsn1","pfxValidator","INTEGER","optional","OCTETSTRING","safeBagValidator","SET","attributeValidator","certBagValidator","_getBagsByAttribute","safeContents","attrName","attrValue","bagType","result","i","length","j","safeBags","bag","undefined","push","attributes","indexOf","pkcs12FromAsn1","obj","strict","password","errors","validate","error","Error","pfx","version","charCodeAt","getBags","filter","rval","localKeyId","util","hexToBytes","localKeyIdHex","friendlyName","getBagsByFriendlyName","getBagsByLocalKeyId","derToOid","contentType","oids","data","oid","content","_decodePkcs7Data","mac","md","macKeyBytes","macAlgorithm","sha1","create","sha256","sha384","sha512","md5","macSalt","ByteBuffer","macIterations","parseInt","bytesToHex","macKey","generateKey","hmac","start","update","macValue","getMac","getBytes","macDigest","_decodeAuthenticatedSafe","composed","createBuffer","putBytes","authSafe","fromDer","contentInfo","encrypted","encryptedData","_decryptSafeContents","_decodeSafeContents","pkcs7","encryptedDataValidator","encAlgorithm","cipher","pbe","getCipher","encParameter","encryptedContentAsn1","finish","output","res","safeBag","bagId","_decodeBagAttributes","bagAttributes","validator","decoder","bagAsn1","bagValue","pkcs8ShroudedKeyBag","decryptPrivateKeyInfo","keyBag","key","privateKeyFromAsn1","e","certBag","certId","x509Certificate","certAsn1","cert","certificateFromAsn1","decodedAttrs","values","toPkcs12Asn1","options","saltSize","count","algorithm","useMac","generateLocalKeyId","bagAttrs","pairedCert","isArray","certificateFromPem","toDer","certificateToAsn1","digest","random","attrs","oidToDer","BMPSTRING","contents","chain","certSafeBags","certBagAttrs","certSafeBag","certSafeContents","certCI","pkAsn1","wrapRsaPrivateKey","privateKeyToAsn1","encryptPrivateKeyInfo","keySafeContents","keyCI","safe","macData","NULL","integerToDer","generatePkcs12Key"],"sources":["C:/Users/frexm/Desktop/ProductListing/node_modules/node-forge/lib/pkcs12.js"],"sourcesContent":["/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./hmac');\nrequire('./oids');\nrequire('./pkcs7asn1');\nrequire('./pbe');\nrequire('./random');\nrequire('./rsa');\nrequire('./sha1');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\n\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\n\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  },\n  contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,  // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\n\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\n\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\n\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for(var i = 0; i < safeContents.length; i++) {\n    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n      if(bagType !== undefined && bag.type !== bagType) {\n        continue;\n      }\n      // only filter by bag type, no attribute specified\n      if(attrName === null) {\n        result.push(bag);\n        continue;\n      }\n      if(bag.attributes[attrName] !== undefined &&\n        bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */\np12.pkcs12FromAsn1 = function(obj, strict, password) {\n  // handle args\n  if(typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if(strict === undefined) {\n    strict = true;\n  }\n\n  // validate PFX and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' +\n      'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */\n    getBags: function(filter) {\n      var rval = {};\n\n      var localKeyId;\n      if('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      }\n\n      // filter on bagType only\n      if(localKeyId === undefined && !('friendlyName' in filter) &&\n        'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(\n          pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if(localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(\n          pfx.safeContents, 'localKeyId',\n          localKeyId, filter.bagType);\n      }\n      if('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(\n          pfx.safeContents, 'friendlyName',\n          filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */\n    getBagsByFriendlyName: function(friendlyName, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */\n    getBagsByLocalKeyId: function(localKeyId, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if(capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n  if(data.tagClass !== asn1.Class.UNIVERSAL ||\n     data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n  data = _decodePkcs7Data(data);\n\n  // check for MAC\n  if(capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n    switch(macAlgorithm) {\n    case pki.oids.sha1:\n      md = forge.md.sha1.create();\n      macKeyBytes = 20;\n      break;\n    case pki.oids.sha256:\n      md = forge.md.sha256.create();\n      macKeyBytes = 32;\n      break;\n    case pki.oids.sha384:\n      md = forge.md.sha384.create();\n      macKeyBytes = 48;\n      break;\n    case pki.oids.sha512:\n      md = forge.md.sha512.create();\n      macKeyBytes = 64;\n      break;\n    case pki.oids.md5:\n      md = forge.md.md5.create();\n      macKeyBytes = 16;\n      break;\n    }\n    if(md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    }\n\n    // verify MAC (iterations default to 1)\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = (('macIterations' in capture) ?\n      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\n    var macKey = p12.generateKey(\n      password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n    if(macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n  return pfx;\n};\n\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if(data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n    for(var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n  return data;\n}\n\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\n\n  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\n     authSafe.type !== asn1.Type.SEQUENCE ||\n     authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\n      'SEQUENCE OF ContentInfo');\n  }\n\n  for(var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i];\n\n    // validate contentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n    switch(asn1.derToOid(capture.contentType)) {\n    case pki.oids.data:\n      if(data.tagClass !== asn1.Class.UNIVERSAL ||\n         data.type !== asn1.Type.OCTETSTRING) {\n        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n      }\n      safeContents = _decodePkcs7Data(data).value;\n      break;\n    case pki.oids.encryptedData:\n      safeContents = _decryptSafeContents(data, password);\n      obj.encrypted = true;\n      break;\n    default:\n      var error = new Error('Unsupported PKCS#12 contentType.');\n      error.contentType = asn1.derToOid(capture.contentType);\n      throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(\n    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n  if(oid !== pki.oids.data) {\n    var error = new Error(\n      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  }\n\n  // get cipher\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n\n  // get encrypted data\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n\n  cipher.update(encrypted);\n  if(!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if(!strict && safeContents.length === 0) {\n    return [];\n  }\n\n  // actually it's BER-encoded\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\n    safeContents.type !== asn1.Type.SEQUENCE ||\n    safeContents.constructed !== true) {\n    throw new Error(\n      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n  for(var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i];\n\n    // validate SafeBag and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Create bag object and push to result array. */\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n    switch(bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n        if(bagAsn1 === null) {\n          throw new Error(\n            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n        /* fall through */\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch(e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n        continue;  /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n        decoder = function() {\n          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error(\n              'Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          }\n\n          // true=produce cert hash\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch(e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n    if(validator !== undefined &&\n       !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Call decoder function from above to store the results. */\n    decoder();\n  }\n\n  return res;\n}\n\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if(attributes !== undefined) {\n    for(var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n      if(pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n      for(var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */\np12.toPkcs12Asn1 = function(key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n  if(!('useMac' in options)) {\n    options.useMac = true;\n  }\n  if(!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n  if(!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n  if(localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if(options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if(cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n      if(typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n  if(localKeyId !== null) {\n    attrs.push(\n      // localKeyID\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            localKeyId)\n        ])\n      ]));\n  }\n  if('friendlyName' in options) {\n    attrs.push(\n      // friendlyName\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\n            options.friendlyName)\n        ])\n      ]));\n  }\n\n  if(attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  }\n\n  // collect contents for AuthenticatedSafe\n  var contents = [];\n\n  // create safe bag(s) for certificate chain\n  var chain = [];\n  if(cert !== null) {\n    if(forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n  for(var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n    if(typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    }\n\n    // SafeBag\n    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.certBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // CertBag\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // certId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n            // certValue (x509Certificate)\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n                asn1.toDer(certAsn1).getBytes())\n            ])])]),\n        // bagAttributes (OPTIONAL)\n        certBagAttrs\n      ]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if(certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n\n    // ContentInfo\n    var certCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(certSafeContents).getBytes())\n        ])\n      ]);\n    contents.push(certCI);\n  }\n\n  // create safe contents for private key\n  var keyBag = null;\n  if(key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n    if(password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.keyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // PrivateKeyInfo\n          pkAsn1\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // EncryptedPrivateKeyInfo\n          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    }\n\n    // SafeContents\n    var keySafeContents =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n\n    // ContentInfo\n    var keyCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(keySafeContents).getBytes())\n        ])\n      ]);\n    contents.push(keyCI);\n  }\n\n  // create AuthenticatedSafe by stringing together the contents\n  var safe = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n\n  var macData;\n  if(options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(\n      forge.random.getBytes(options.saltSize));\n    var count = options.count;\n    // 160-bit key\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // mac DigestInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // digestAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm = SHA-1\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(pki.oids.sha1).getBytes()),\n          // parameters = Null\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n        ]),\n        // digest\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\n          false, macValue.getBytes())\n      ]),\n      // macSalt OCTET STRING\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n      // iterations INTEGER (XXX: Only support count < 65536)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(count).getBytes()\n      )\n    ]);\n  }\n\n  // PFX\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (3)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(3).getBytes()),\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // contentType\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        // OID for the content type is 'data'\n        asn1.oidToDer(pki.oids.data).getBytes()),\n      // content\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n          asn1.toDer(safe).getBytes())\n      ])\n    ]),\n    macData\n  ]);\n};\n\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\np12.generateKey = forge.pbe.generatePkcs12Key;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,aAAD,CAAP;;AACAA,OAAO,CAAC,OAAD,CAAP;;AACAA,OAAO,CAAC,UAAD,CAAP;;AACAA,OAAO,CAAC,OAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP,C,CAEA;;;AACA,IAAIC,IAAI,GAAGF,KAAK,CAACE,IAAjB;AACA,IAAIC,GAAG,GAAGH,KAAK,CAACG,GAAhB,C,CAEA;;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAP,GAAiBN,KAAK,CAACO,MAAN,GAAeP,KAAK,CAACO,MAAN,IAAgB,EAA1D;AAEA,IAAIC,oBAAoB,GAAG;EACzBC,IAAI,EAAE,aADmB;EAEzBC,QAAQ,EAAER,IAAI,CAACS,KAAL,CAAWC,SAFI;EAGzBC,IAAI,EAAEX,IAAI,CAACY,IAAL,CAAUC,QAHS;EAGE;EAC3BC,WAAW,EAAE,IAJY;EAKzBC,KAAK,EAAE,CAAC;IACNR,IAAI,EAAE,yBADA;IAENC,QAAQ,EAAE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"},"metadata":{},"sourceType":"script"}